###  异步接口任务  无序 => 有序

```javascript
//id 数组 => 由接口请求返回

getIds({...参数}).then(res=>{
    let ids = res.indexIDs //拿到id 后需要 接口请求id对应的数据
})
```

#### 解决方法 1 async await

```javascript
// data
data：{
    //示例数据
    tableData:[{id:1}]
}

getIds({...参数}).then(res=>{
    let ids = res.indexIDs //拿到id 后需要 接口请求id对应的数据
    this.getInfo(ids);
})

async getInfo(data){
    for(let i=0;i<=data.length;i++){
        await getInfos().then(res=>{
            //...do something
            this.tableData.push(res);
        })
    }
}

```

#### 解决方法 2  占位标识 

```javascript
// data
data：{
    //示例数据
    tableData:[{id:1}]
}

// methods
getIds({...参数}).then(res=>{
    let ids = res.indexIDs //拿到id 后需要 接口请求id对应的数据
    ids.foreach(item=>{
        this.tableData.push({id:item})
    })
    ids.foreach(item=>{
        this.getInfo(item);
    })

})

getInfo(id){
   getInfos().then(res=>{
      //...do something
        this.tableData.foreach((item,index)=>{
            if(item.id === item){
                this.$set(this.tableData,index,res)
            }
        })
   })
}

```

#### 解决方法 3 递归

```javascript
// data
data：{
    //示例数据
    tableData:[{id:1}]
}

getIds({...参数}).then(res=>{
    let ids = res.indexIDs //拿到id 后需要 接口请求id对应的数据
    this.getInfo(ids);
})

getInfo(data,index){
    let len = data.length;
    getInfos().then(res=>{
        //...do something
        this.tableData.push(res);
        index++;
        if(index< len){
            this.getInfo(data,index)
        }
    })
}

```


###  锚点定位

```html

  <ul>
    <li>1111</li>
    <li>2222</li>
    <li id="header">3333</li>
    <li>4444</li>
    <li>5555</li>
    <li>6666</li>
    <li id="footer">7777</li>
  </ul>

```

```javascript

  let _ul = document.getElementById('footer')
  const _old = function (event) {
    // 利用 a 标签的特性进行锚点定位
    let btn = document.createElement('a')
    btn.href = '#header'
    btn.click()
    // 将节点btn追加到body中
    document.body.appendChild(btn)
    // 没有document.appendChild(btn) 不用删除
    document.body.removeChild(btn)
  }
  _ul.addEventListener('click', _old, false)

```


### input 


```html

<!-- type 为 number 的时候 可以输入 e 因为 e 在数学上代表数字 -->
<input type="number"> 

```

```javascript
// 资源包压缩 插件
"vue-cli-plugin-zyb"


zyb-js-sdk
```


### cocos 相关

#### 帧

资料 => https://www.cnblogs.com/coco1s/archive/2017/12/13/8029582.html

> 目前大多数设备的屏幕刷新率为 60 次/秒，所以通常来讲 FPS 为 60 frame/s 时动画效果最好，也就是每帧的消耗时间为 16.67ms。


> 直观感受，不同帧率的体验：
帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；
帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；
帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；
帧率波动很大的动画，亦会使人感觉到卡顿。

```javascript
 帧单位转秒
0010 => (16.67 * 10) / 1000

```

#### api. tween
参数值
```javascript
  scale=>缩放
  opacity=>透明度
  rotation => 旋转 （废弃了）
  angle => 旋转 
  position => 定位
  x,y => x,y 坐标变化
```



### window.requestAnimationFrame()

> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

**官方案例**

```html
  <div id="some-element-you-want-to-animate" style="width: 100px;height:100px;background-color: #000;"></div>

```

```javascript
  const element = document.getElementById('some-element-you-want-to-animate');
  let start;

  function step(timestamp) {
    if (start === undefined)
      start = timestamp;
    const elapsed = timestamp - start;

    // `Math.min()` is used here to make sure that the element stops at exactly 200px.
    element.style.transform = 'translateX(' + Math.min(0.1 * elapsed, 200) + 'px)';

    if (elapsed < 2000) { // Stop the animation after 2 seconds
      window.requestAnimationFrame(step);
    }
  }

  window.requestAnimationFrame(step);
```

### 心得总结
编程 => 解决做不出来的问题
架构 => 解决做不大的问题
工程 => 解决很多人没法一起做的问题











