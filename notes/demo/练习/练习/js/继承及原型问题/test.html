<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>继承</title>
</head>

<body>

</body>
<!-- 继承1 通过原型继承 -->
<script>
    // 定义父类
    function Person() {
        this.name = 'renlingin';
        this.age = 34;
        this.calls = function () {
            console.log(this.name)
        }
    }

    let renlingxin = new Person();
    //  定义子类
    function People() {
        this.tall = '32cm'
    }
    People.prototype = renlingxin;

    let jiejie = new People();
    let renren = new People();

    jiejie.calls();
    console.log(jiejie);
    console.log(jiejie.name)
    console.log(jiejie.tall)

    jiejie.name = 'jielixin';
    console.log(jiejie.name);
    console.log(renren.name);
</script>
<!-- 继承2  组合式继承 原型继承方法  call改变this指向 继承属性-->
<script>
    // 定义父类  接受属性值并且赋值
    function Animal(name) {
        this.name = name,
            this.size = 1212
    }
    Animal.prototype.seeName = function () {
        console.log(this.name)
    }
    // 定义子类  定义name 传递属性值
    function lettle(name) {
        Animal.call(this, name);
        this.son = '子类'
    }
    lettle.prototype = new Animal();
    lettle.prototype.gooSize = function () {
        console.log(this.size);
    }
    let son1 = new lettle('renlingxin');
    let son2 = new lettle('世界人民万岁');

    // 实例拥有自己的值，不会相互影响
    console.log(son1);
    son1.name = 'xxxxx';
    console.log(son1);
    console.log(son2);
</script>

<!-- es6继承 -->
<script>
    class name {
        constructor() {
            this.too = 2222;
        }
        comeGo() {
            console.log(this.too)
        };
    }

    class big extends name {
        constructor() {
            super();
            this.biga = 232323;
        }

    }

    const one = new big();
    console.log(one)
    one.comeGo()
</script>

</html>