<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>
<!-- 构造函数 call实现继承  -->
<script>
    // 父类
    function Person(name) {
        this.name = name;
        this.colors = ['red', 'green', 'blue'];

        this.getName = function () {
            return this.name;
        }
    }
    // 子类
    function People(name) {
        // 继承Person,同时传递参数
        Person.call(this, name);

        // 实例属性
        this.age = 20;
    }
    // 创建子类实例
    var instance1 = new People('Tom');
    instance1.colors.push('black');
    console.log(instance1.name); // "Tom"
    console.log(instance1.getName()); // "Tom"
    console.log(instance1.age); // 20
    console.log(instance1.colors); // ['red', 'blue', 'green', 'black']
    var instance2 = new People('Peter');
    console.log(instance2.name); // "Peter"
    console.log(instance2.getName()); // "Peter"
    console.log(instance2.age); // 20
    console.log(instance2.colors);//["red", "green", "blue"]
    // 缺点1. 如果方法都在构造函数中定义，那么就无法复用函数。每次构建实例时都会在实例中保留方法函数，
    // 造成了内存的浪费，同时也无法实现同步更新，因为每个实例都是单独的方法函数。如果方法写在prototype上
    // ，就只会有一份，更新时候会做到同步更新。
</script>

</html>